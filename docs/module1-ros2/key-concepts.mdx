---
title: Key Concepts in ROS 2
sidebar_label: Key Concepts
---

# Key Concepts in ROS 2

## Nodes

A node is the fundamental unit of computation in ROS 2. It's a process that performs computation and communicates with other nodes through messages. In humanoid robotics, nodes might represent different subsystems like perception, planning, control, or specific sensor/actuator interfaces.

### Creating a Node in Python (rclpy)

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalNode()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Topics and Messages

Topics are named buses over which nodes exchange messages. Messages are the data packets sent between nodes. In humanoid robotics, topics might carry sensor data, control commands, or state information.

### Publisher Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class PublisherNode(Node):
    def __init__(self):
        super().__init__('publisher_node')
        self.publisher = self.create_publisher(String, 'robot_status', 10)
        self.timer = self.create_timer(1.0, self.publish_status)
        
    def publish_status(self):
        msg = String()
        msg.data = 'Robot is operational'
        self.publisher.publish(msg)
        self.get_logger().info(f'Published: {msg.data}')

def main():
    rclpy.init()
    node = PublisherNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Subscriber Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SubscriberNode(Node):
    def __init__(self):
        super().__init__('subscriber_node')
        self.subscription = self.create_subscription(
            String,
            'robot_status',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: {msg.data}')

def main():
    rclpy.init()
    node = SubscriberNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Services

Services provide synchronous, bidirectional communication. A client sends a request and waits for a response from a server. In humanoid robotics, services might be used for tasks like requesting a specific action or querying robot state.

### Service Definition (example_srv.srv)

```
# Request
string name
int64 age
---
# Response
bool success
string message
```

### Service Server Example

```python
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))
        return response

def main():
    rclpy.init()
    minimal_service = MinimalService()
    rclpy.spin(minimal_service)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client Example

```python
import sys
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class MinimalClientAsync(Node):
    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main():
    rclpy.init()
    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    minimal_client.get_logger().info(
        'Result of add_two_ints: for %d + %d = %d' %
        (int(sys.argv[1]), int(sys.argv[2]), response.sum))
    minimal_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Actions

Actions are used for long-running tasks that may provide feedback during execution. They support goals, results, and feedback. In humanoid robotics, actions might be used for complex tasks like walking to a location or grasping an object.

### Action Definition (Fibonacci.action)

```
#goal definition
int32 order
---
#result definition
int32[] sequence
---
#feedback
int32[] sequence
```

### Action Server Example

```python
from rclpy.action import ActionServer
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')
        
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]
        
        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()
            
            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])
            
            self.get_logger().info(f'Publishing feedback: {feedback_msg.sequence}')
            goal_handle.publish_feedback(feedback_msg)
        
        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Returning result: {result.sequence}')
        
        return result

def main():
    rclpy.init()
    fibonacci_action_server = FibonacciActionServer()
    rclpy.spin(fibonacci_action_server)
    fibonacci_action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Parameters

Parameters are key-value pairs that can be configured at runtime. They're useful for configuring node behavior without recompiling.

### Parameter Example

```python
import rclpy
from rclpy.node import Node

class ParameterNode(Node):
    def __init__(self):
        super().__init__('parameter_node')
        
        # Declare parameters with default values
        self.declare_parameter('robot_name', 'humanoid_robot')
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('safety_mode', True)
        
        # Get parameter values
        self.robot_name = self.get_parameter('robot_name').value
        self.max_velocity = self.get_parameter('max_velocity').value
        self.safety_mode = self.get_parameter('safety_mode').value
        
        self.get_logger().info(f'Robot name: {self.robot_name}')
        self.get_logger().info(f'Max velocity: {self.max_velocity}')
        self.get_logger().info(f'Safety mode: {self.safety_mode}')

def main():
    rclpy.init()
    node = ParameterNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Packages

A package is the basic building block of a ROS 2 system. It contains nodes, libraries, and other resources. A package typically includes:

- **package.xml**: Package manifest with metadata and dependencies
- **CMakeLists.txt**: Build configuration for C++ packages
- **setup.py**: Build configuration for Python packages
- **src/**: Source code files
- **launch/**: Launch files for starting multiple nodes
- **config/**: Configuration files
- **test/**: Test files

### Example package.xml

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>humanoid_robot_control</name>
  <version>0.0.1</version>
  <description>Control package for humanoid robot</description>
  <maintainer email="developer@example.com">Developer Name</maintainer>
  <license>Apache License 2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

## Launch Files

Launch files allow you to start multiple nodes with a single command. They're written in Python and provide a way to configure and run complex systems.

### Example Launch File

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='humanoid_robot_control',
            executable='walking_controller',
            name='walking_controller',
            parameters=[
                {'step_height': 0.05},
                {'step_length': 0.3},
                {'max_velocity': 0.5}
            ],
            remappings=[
                ('/joint_states', '/robot/joint_states'),
                ('/cmd_vel', '/robot/cmd_vel')
            ]
        ),
        Node(
            package='humanoid_robot_control',
            executable='balance_controller',
            name='balance_controller',
            parameters=[
                {'kp': 1.0},
                {'ki': 0.1},
                {'kd': 0.05}
            ]
        )
    ])
```

## Quality of Service (QoS)

QoS policies allow you to configure how messages are delivered:

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

# Create a QoS profile for sensor data (keep last 10 samples, best effort)
sensor_qos = QoSProfile(
    depth=10,
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST
)

# Create a QoS profile for critical control data (reliable, keep all)
control_qos = QoSProfile(
    depth=1,
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_ALL
)

# Use QoS when creating publisher/subscriber
publisher = self.create_publisher(String, 'critical_topic', control_qos)
subscriber = self.create_subscription(String, 'sensor_topic', callback, sensor_qos)
```

## Namespaces

Namespaces provide a way to organize nodes and topics in a hierarchical structure:

```python
# Create a node with a namespace
node = rclpy.create_node('my_node', namespace='robot1')

# This node will have topics like /robot1/topic_name
```

## Summary

Understanding these key concepts is essential for developing effective ROS 2 applications for humanoid robotics. Each concept serves a specific purpose in creating distributed, reliable, and maintainable robotic systems. As you progress through the labs, you'll get hands-on experience with these concepts in practical scenarios.